/// Data models for the Klarita application, designed to match the revamped API.

// Represents the priority of a task
enum TaskPriority { low, medium, high }

// Represents a single task generated by the AI
class Task {
  final int id;
  final String title;
  final String? description;
  final int? estimatedDuration;
  final int? position;
  final TaskPriority priority;
  final String status; // "pending", "active", "completed"

  Task({
    required this.id,
    required this.title,
    this.description,
    this.estimatedDuration,
    this.position,
    this.priority = TaskPriority.medium,
    this.status = "pending",
  });

  factory Task.fromJson(Map<String, dynamic> json) {
    return Task(
      id: json['id'],
      title: json['title'],
      description: json['description'],
      estimatedDuration: json['estimated_duration'],
      position: json['position'],
      priority: TaskPriority.values.firstWhere(
        (e) => e.toString().split('.').last == json['priority'],
        orElse: () => TaskPriority.medium,
      ),
      status: json['status'] ?? "pending",
    );
  }

  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'description': description,
        'estimated_duration': estimatedDuration,
        'priority': priority.toString().split('.').last,
        'status': status,
        'position': position,
      };
  
  // Helper property for backward compatibility
  bool get completed => status == "completed";
}

// Represents an interactive task breakdown session
class TaskSession {
  final int id;
  final String originalGoal;
  final String status; // "draft", "active", "completed"
  final DateTime createdAt;
  final List<Task> tasks;
  final String? aiMessage;

  TaskSession({
    required this.id,
    required this.originalGoal,
    required this.status,
    required this.createdAt,
    this.tasks = const [],
    this.aiMessage,
  });

  factory TaskSession.fromJson(Map<String, dynamic> json) {
    var taskList = (json['tasks'] as List)
        .map((taskJson) => Task.fromJson(taskJson))
        .toList();

    return TaskSession(
      id: json['id'],
      originalGoal: json['original_goal'] ?? '', // Handle potential null
      status: json['status'],
      createdAt: json['created_at'] != null ? DateTime.parse(json['created_at']) : DateTime.now(),
      tasks: taskList,
      aiMessage: json['ai_message'],
    );
  }

  Map<String, dynamic> toJson() => {
        'id': id,
        'original_goal': originalGoal,
        'status': status,
        'created_at': createdAt.toIso8601String(),
        'tasks': tasks.map((t) => t.toJson()).toList(),
      };
}

// Represents the user's gamification profile
class UserGamification {
  final int points;
  final int level;
  final int currentStreak;
  final int longestStreak;
  final List<Badge> badges;

  UserGamification({
    required this.points,
    required this.level,
    required this.currentStreak,
    required this.longestStreak,
    this.badges = const [],
  });

  factory UserGamification.fromJson(Map<String, dynamic> json) {
    var badgeList = (json['badges'] as List?)
        ?.map((badgeJson) => Badge.fromJson(badgeJson))
        .toList() ?? [];
        
    return UserGamification(
      points: json['points'] ?? 0,
      level: json['level'] ?? 1,
      currentStreak: json['current_streak'] ?? 0,
      longestStreak: json['longest_streak'] ?? 0,
      badges: badgeList,
    );
  }
  
  Map<String, dynamic> toJson() => {
        'points': points,
        'level': level,
        'current_streak': currentStreak,
        'longest_streak': longestStreak,
        'badges': badges.map((b) => b.toJson()).toList(),
      };
}

// Represents a badge that can be earned
class Badge {
  final String name;
  final String description;
  final String icon;

  Badge({
    required this.name,
    required this.description,
    required this.icon,
  });

  factory Badge.fromJson(Map<String, dynamic> json) {
    return Badge(
      name: json['name'],
      description: json['description'],
      icon: json['icon'],
    );
  }
  
  Map<String, dynamic> toJson() => {
        'name': name,
        'description': description,
        'icon': icon,
      };
}

// Represents user preferences for AI interaction
class UserPreference {
  final String breakdownStyle;
  final int preferredTaskDuration;
  final String communicationStyle;

  UserPreference({
    required this.breakdownStyle,
    required this.preferredTaskDuration,
    required this.communicationStyle,
  });

  factory UserPreference.fromJson(Map<String, dynamic> json) {
    return UserPreference(
      breakdownStyle: json['breakdown_style'],
      preferredTaskDuration: json['preferred_task_duration'],
      communicationStyle: json['communication_style'],
    );
  }
}

// Represents session completion statistics
class SessionCompletionStats {
  final int completedTasks;
  final int totalTasks;
  final double completionRate;

  SessionCompletionStats({
    required this.completedTasks,
    required this.totalTasks,
    required this.completionRate,
  });

  bool get isComplete => completedTasks == totalTasks && totalTasks > 0;
  bool get isPartiallyComplete => completedTasks > 0 && completedTasks < totalTasks;
  int get remainingTasks => totalTasks - completedTasks;
  int get completionPercentage => (completionRate * 100).round();
} 