/// Data models for the Klarita application, designed to match the revamped API.

// Represents the priority of a task
enum TaskPriority { low, medium, high }

// Represents a single task generated by the AI
class Task {
  final int id;
  final String title;
  final String? description;
  final int? estimatedDuration;
  final TaskPriority priority;
  final bool completed;

  Task({
    required this.id,
    required this.title,
    this.description,
    this.estimatedDuration,
    this.priority = TaskPriority.medium,
    this.completed = false,
  });

  factory Task.fromJson(Map<String, dynamic> json) {
    return Task(
      id: json['id'],
      title: json['title'],
      description: json['description'],
      estimatedDuration: json['estimated_duration'],
      priority: TaskPriority.values.firstWhere(
        (e) => e.toString().split('.').last == json['priority'],
        orElse: () => TaskPriority.medium,
      ),
      completed: json['completed'] ?? false,
    );
  }
}

// Represents an interactive task breakdown session
class TaskSession {
  final int id;
  final String originalGoal;
  final String status; // "draft", "active", "completed"
  final DateTime createdAt;
  final List<Task> tasks;
  final String? aiMessage;

  TaskSession({
    required this.id,
    required this.originalGoal,
    required this.status,
    required this.createdAt,
    this.tasks = const [],
    this.aiMessage,
  });

  factory TaskSession.fromJson(Map<String, dynamic> json) {
    var taskList = (json['tasks'] as List)
        .map((taskJson) => Task.fromJson(taskJson))
        .toList();

    return TaskSession(
      id: json['id'],
      originalGoal: json['original_goal'] ?? '', // Handle potential null
      status: json['status'],
      createdAt: json['created_at'] != null ? DateTime.parse(json['created_at']) : DateTime.now(),
      tasks: taskList,
      aiMessage: json['ai_message'],
    );
  }
}

// Represents the user's gamification profile
class UserGamification {
  final int points;
  final int level;
  final int currentStreak;
  final int longestStreak;
  final List<Badge> badges;

  UserGamification({
    required this.points,
    required this.level,
    required this.currentStreak,
    required this.longestStreak,
    this.badges = const [],
  });

  factory UserGamification.fromJson(Map<String, dynamic> json) {
    var badgeList = (json['badges'] as List)
        .map((badgeJson) => Badge.fromJson(badgeJson))
        .toList();
        
    return UserGamification(
      points: json['points'],
      level: json['level'],
      currentStreak: json['current_streak'],
      longestStreak: json['longest_streak'],
      badges: badgeList,
    );
  }
}

// Represents a badge that can be earned
class Badge {
  final String name;
  final String description;
  final String icon;

  Badge({
    required this.name,
    required this.description,
    required this.icon,
  });

  factory Badge.fromJson(Map<String, dynamic> json) {
    return Badge(
      name: json['name'],
      description: json['description'],
      icon: json['icon'],
    );
  }
}

// Represents user preferences for AI interaction
class UserPreference {
  final String breakdownStyle;
  final int preferredTaskDuration;
  final String communicationStyle;

  UserPreference({
    required this.breakdownStyle,
    required this.preferredTaskDuration,
    required this.communicationStyle,
  });

  factory UserPreference.fromJson(Map<String, dynamic> json) {
    return UserPreference(
      breakdownStyle: json['breakdown_style'],
      preferredTaskDuration: json['preferred_task_duration'],
      communicationStyle: json['communication_style'],
    );
  }
} 